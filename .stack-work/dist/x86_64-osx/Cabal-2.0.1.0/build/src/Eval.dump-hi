
==================== FINAL INTERFACE ====================
2018-06-03 19:10:30.258272 UTC

interface LETLanguage-0.1.0.0-AjjNVn9s5sDzZ7DWIwnd3:Eval 8022
  interface hash: ba1d06c8758eda9d997362046c551ae8
  ABI hash: ed28d64d5b1bdeef2bb1a757deebcc00
  export-list hash: 1ef6ef26e2595d2119d1f07d04f4a440
  orphan hash: 16edf6f44760453a0b10a31aff96946e
  flag hash: da92623ea998ab273ee924eaf462f7dc
  sig of: Nothing
  used TH splices: False
  where
exports:
  Eval.evaluate
  Eval.run
module dependencies: Expr Parser Val
package dependencies: array-0.5.2.0 base-4.10.1.0* binary-0.8.5.1
                      bytestring-0.10.8.2 containers-0.5.10.2 deepseq-1.4.3.0
                      ghc-prim-0.5.1.1 integer-gmp-1.0.1.0 mtl-2.2.2 parsec-3.1.13.0
                      text-1.2.3.0 transformers-0.5.2.0
orphans: text-1.2.3.0:Data.Text.Lazy text-1.2.3.0:Data.Text
         binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show
         transformers-0.5.2.0:Control.Monad.Trans.Error
         base-4.10.1.0:GHC.Float base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Complex base-4.10.1.0:Data.Either
                         base-4.10.1.0:Data.Functor.Compose base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity
                         base-4.10.1.0:Data.Functor.Product base-4.10.1.0:Data.Functor.Sum
                         base-4.10.1.0:Data.List.NonEmpty base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Semigroup base-4.10.1.0:Data.Type.Equality
                         base-4.10.1.0:Data.Version base-4.10.1.0:Data.Void
                         base-4.10.1.0:GHC.Exts base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats containers-0.5.10.2:Data.IntMap.Internal
                         containers-0.5.10.2:Data.IntSet.Internal
                         containers-0.5.10.2:Data.Map.Internal
                         containers-0.5.10.2:Data.Sequence.Internal
                         containers-0.5.10.2:Data.Set.Internal containers-0.5.10.2:Data.Tree
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
import  -/  Expr 1946f3d5e4e1b0477553faf101bde29c
  exports: 28d47d405e73ed0c9ea2a32301e251cb
  BinOp c2d52bd6e3a88c342a014f5b1c4eb0e9
  Cons a69933727ff05980398db38e21aaf1ba
  Expr 51bc52830c149d81e81cae33e098648e
  I 31f94b154aaa7860343b8c6b5ac95e1e
  If 9fc4f0370f7f2485261e6bbb3d540aaa
  Let a9d5e347751b315444bca2cc7c14eea7
  LetRec cfaa92f88959fc3d193bb72a61da5b28
  ListUnOp 4f999f52af4c0fb5f6eafcb65d01e2a0
  Nil 7210e6eee1fc6c788ba3cd9a35418644
  UnOp 68d1eca7642d7f3aa71fc1b1f83b264f
  Unpack 92e4304ec163cda8bea90162d88adcd1
  Var bdcdb66782eb571262f2ccf7aebeb3d6
import  -/  Parser e7fe8c6cb9cd47ec2c29f05be4803a1a
  exports: 13b4d8f8b916dd359647b0e20a83de4d
  parseProgram a8af7fc9cf7e8e1f29696f076b6ae355
import  -/  Val 39961ad844af2fe8f0995479f4c85015
  exports: 657dcda7d5828675d2309443963dc934
  VInt 2b5361c2f8398e204500bfd8e32d9789
  VList 94c7680fb05cd25d999583298f36c121
  Val a01b0276a2b7fa8b8c11ed084c5e56ac
  val2Bool a01f0314112ae02b33736efd8188bfb2
  val2Int 70f310f232f8fd9f7ebc18b4b0759a17
  val2List 2b03b3c72c1ca5713378d912927251a8
import  -/  base-4.10.1.0:Data.Either d7dae5d9bf298dee616e465c14b5d60e
import  -/  base-4.10.1.0:Data.Foldable 9ed87455d68e87ff2b5b8725eae9897e
import  -/  base-4.10.1.0:Data.Functor 2ffda4f936b8f474394d93205750aff3
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:GHC.List e3060fbeb44ce0038e6b4dedf2dd9cf1
import  -/  base-4.10.1.0:GHC.Show 0a8ce2b5e533d1c2cfb7954e6736be45
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  containers-0.5.10.2:Data.Map 938962634b7a30eebc77b8948269128a
import  -/  containers-0.5.10.2:Data.Map.Internal 9c57d7e8180b3d401d116f2112d8715d
import  -/  ghc-prim-0.5.1.1:GHC.Classes 93e2660065dce9329577e83d76d8f0d4
import  -/  mtl-2.2.2:Control.Monad.Error.Class 2adfab0432a1e2ba3b17fda5c892a24c
import  -/  mtl-2.2.2:Control.Monad.Except 67b2229f0dd27ff895cb1fdcade8078a
import  -/  mtl-2.2.2:Control.Monad.State 4acb2e6037f370fa4b91900d626e6406
import  -/  mtl-2.2.2:Control.Monad.State.Class de8813e114276746770717ab3ee06916
import  -/  parsec-3.1.13.0:Text.Parsec 98254be179cca518f0ed313744ac6763
import  -/  parsec-3.1.13.0:Text.Parsec.Error 9a2acf4ad512c1c28143234fa3e0a63a
import  -/  parsec-3.1.13.0:Text.Parsec.Pos c716f6c8601ee77f59c16f78601f1607
import  -/  transformers-0.5.2.0:Control.Monad.Trans.State.Lazy 1a80bdb936666c1b8faf2f03f91a48cc
0c2750315f4db9bd7d2f89edc7a4783c
  $s$fApplicativeStateT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either GHC.Base.String))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s (Data.Either.Either GHC.Base.String))
                  (Eval.$s$fApplicativeStateT_$s$fFunctorStateT @ s)
                  (Eval.$s$fApplicativeStateT_$s$fApplicativeStateT_$cpure @ s)
                  (Eval.$s$fApplicativeStateT_$s$fApplicativeStateT_$c<*> @ s)
                  (Control.Monad.Trans.State.Lazy.$fAlternativeStateT2
                     @ (Data.Either.Either GHC.Base.String)
                     @ s
                     (Data.Either.$fFunctorEither @ [GHC.Types.Char])
                     (Data.Either.$fMonadEither @ [GHC.Types.Char]))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s (Data.Either.Either GHC.Base.String) a>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s (Data.Either.Either GHC.Base.String) b>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N <Data.Either.Either GHC.Base.String>_R <c>_N))
                  (Control.Monad.Trans.State.Lazy.$fApplicativeStateT1
                     @ (Data.Either.Either GHC.Base.String)
                     @ s
                     (Data.Either.$fFunctorEither @ [GHC.Types.Char])
                     (Data.Either.$fMonadEither @ [GHC.Types.Char]))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Trans.State.Lazy.StateT
                      s (Data.Either.Either GHC.Base.String) a>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s (Data.Either.Either GHC.Base.String) b>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N <Data.Either.Either GHC.Base.String>_R <b>_N))
                  (\ @ a
                     @ b
                     (x :: Control.Monad.Trans.State.Lazy.StateT
                             s (Data.Either.Either GHC.Base.String) a)
                     (eta4 :: Control.Monad.Trans.State.Lazy.StateT
                                s (Data.Either.Either GHC.Base.String) b)
                     (eta5 :: s) ->
                   case x `cast`
                        (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <s>_N <Data.Either.Either GHC.Base.String>_R <a>_N)
                          eta5 of wild {
                     Data.Either.Left x1
                     -> Data.Either.Left @ [GHC.Types.Char] @ (a, s) x1
                     Data.Either.Right y
                     -> case eta4
                               `cast`
                             (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <Data.Either.Either GHC.Base.String>_R <b>_N)
                               (case y of wild1 { (,) a2 s' -> s' }) of wild1 {
                          Data.Either.Left l
                          -> Data.Either.Left @ [GHC.Types.Char] @ (a, s) l
                          Data.Either.Right r
                          -> Data.Either.Right
                               @ [GHC.Types.Char]
                               @ (a, s)
                               (case y of wild2 { (,) a2 s' -> a2 },
                                case r of wild2 { (,) x1 s'' -> s'' }) } })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Trans.State.Lazy.StateT
                      s (Data.Either.Either GHC.Base.String) a>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s (Data.Either.Either GHC.Base.String) b>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N <Data.Either.Either GHC.Base.String>_R <a>_N)) -}
84f6c60197690bd93adeef759595f221
  $s$fApplicativeStateT_$s$fApplicativeStateT_$c<*> ::
    Control.Monad.Trans.State.Lazy.StateT
      s (Data.Either.Either GHC.Base.String) (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either GHC.Base.String) a
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either GHC.Base.String) b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (ds :: Control.Monad.Trans.State.Lazy.StateT
                            s (Data.Either.Either GHC.Base.String) (a -> b))
                   (ds1 :: Control.Monad.Trans.State.Lazy.StateT
                             s (Data.Either.Either GHC.Base.String) a)
                   (s1 :: s) ->
                 case ds
                        `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <s>_N <Data.Either.Either GHC.Base.String>_R <a -> b>_N)
                        s1 of wild {
                   Data.Either.Left l
                   -> Data.Either.Left @ [GHC.Types.Char] @ (b, s) l
                   Data.Either.Right r
                   -> case ds1
                             `cast`
                           (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <s>_N <Data.Either.Either GHC.Base.String>_R <a>_N)
                             (case r of wild1 { (,) f s' -> s' }) of wild1 {
                        Data.Either.Left l
                        -> Data.Either.Left @ [GHC.Types.Char] @ (b, s) l
                        Data.Either.Right r1
                        -> Data.Either.Right
                             @ [GHC.Types.Char]
                             @ (b, s)
                             (case r of wild2 { (,) f s' ->
                              f (case r1 of wild3 { (,) x s'' -> x }) },
                              case r1 of wild2 { (,) x s'' -> s'' }) } })
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s (Data.Either.Either GHC.Base.String) (a -> b)>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s (Data.Either.Either GHC.Base.String) a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Either.Either GHC.Base.String>_R <b>_N)) -}
ab9c9f83f87f637d7e9cafa91b3e8ec9
  $s$fApplicativeStateT_$s$fApplicativeStateT_$cpure ::
    a
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either GHC.Base.String) a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m2,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s @ a (a2 :: a) (s1 :: s) ->
                 Data.Either.Right @ [GHC.Types.Char] @ (a, s) (a2, s1))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Either.Either GHC.Base.String>_R <a>_N)) -}
6132f192a8d1c8d8b6b66f5ef8bec25e
  $s$fApplicativeStateT_$s$fFunctorStateT ::
    GHC.Base.Functor
      (Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either GHC.Base.String))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s (Data.Either.Either GHC.Base.String))
                  (Control.Monad.Trans.State.Lazy.$fFunctorStateT_$cfmap
                     @ (Data.Either.Either GHC.Base.String)
                     @ s
                     (Data.Either.$fFunctorEither @ [GHC.Types.Char]))
                  (\ @ a
                     @ b
                     (x :: a)
                     (eta4 :: Control.Monad.Trans.State.Lazy.StateT
                                s (Data.Either.Either GHC.Base.String) b)
                     (eta5 :: s) ->
                   case eta4
                          `cast`
                        (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <s>_N <Data.Either.Either GHC.Base.String>_R <b>_N)
                          eta5 of wild {
                     Data.Either.Left x1
                     -> Data.Either.Left @ [GHC.Types.Char] @ (a, s) x1
                     Data.Either.Right y
                     -> Data.Either.Right
                          @ [GHC.Types.Char]
                          @ (a, s)
                          (x, case y of wild1 { (,) a2 s' -> s' }) })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s (Data.Either.Either GHC.Base.String) b>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N <Data.Either.Either GHC.Base.String>_R <a>_N)) -}
1b3cb0fdd856da3928f3a9d97680ead0
  $s$fMonadErroreStateT0 ::
    Control.Monad.Error.Class.MonadError
      [GHC.Types.Char]
      (Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either GHC.Base.String))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ [GHC.Types.Char]
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s (Data.Either.Either GHC.Base.String))
                  (Eval.$s$fMonadErroreStateT0_$s$fMonadStateT @ s)
                  (\ @ a (eta4 :: [GHC.Types.Char]) (s1 :: s) ->
                   Data.Either.Left @ [GHC.Types.Char] @ (a, s) eta4)
                    `cast`
                  (forall (a :: <*>_N).
                   <[GHC.Types.Char]>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N <Data.Either.Either GHC.Base.String>_R <a>_N))
                  (\ @ a
                     (eta4 :: Control.Monad.Trans.State.Lazy.StateT
                                s (Data.Either.Either GHC.Base.String) a)
                     (eta5 :: [GHC.Types.Char]
                              -> Control.Monad.Trans.State.Lazy.StateT
                                   s (Data.Either.Either GHC.Base.String) a)
                     (eta6 :: s) ->
                   case eta4
                          `cast`
                        (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <s>_N <Data.Either.Either GHC.Base.String>_R <a>_N)
                          eta6 of wild {
                     Data.Either.Left l
                     -> (eta5 l)
                          `cast`
                        (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <s>_N <Data.Either.Either GHC.Base.String>_R <a>_N)
                          eta6
                     Data.Either.Right r
                     -> Data.Either.Right @ [GHC.Types.Char] @ (a, s) r })
                    `cast`
                  (forall (a :: <*>_N).
                   <Control.Monad.Trans.State.Lazy.StateT
                      s (Data.Either.Either GHC.Base.String) a>_R
                   ->_R <[GHC.Types.Char]
                         -> Control.Monad.Trans.State.Lazy.StateT
                              s (Data.Either.Either GHC.Base.String) a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N <Data.Either.Either GHC.Base.String>_R <a>_N)) -}
f1b1216f9081b872ae12b30570898cc1
  $s$fMonadErroreStateT0_$s$fMonadStateT ::
    GHC.Base.Monad
      (Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either GHC.Base.String))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s (Data.Either.Either GHC.Base.String))
                  (Eval.$s$fApplicativeStateT @ s)
                  (Eval.$s$fMonadErroreStateT0_$s$fMonadStateT_$c>>= @ s)
                  (Eval.$s$fMonadErroreStateT0_$s$fMonadStateT_$c>> @ s)
                  (\ @ a (eta4 :: a) (eta5 :: s) ->
                   Data.Either.Right @ [GHC.Types.Char] @ (a, s) (eta4, eta5))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N <Data.Either.Either GHC.Base.String>_R <a>_N))
                  (Eval.$s$fMonadErroreStateT0_$s$fMonadStateT_$cfail @ s) -}
96a8e1afa7a2e4f240aebf0e050a7630
  $s$fMonadErroreStateT0_$s$fMonadStateT_$c>> ::
    Control.Monad.Trans.State.Lazy.StateT
      s (Data.Either.Either GHC.Base.String) a
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either GHC.Base.String) b
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either GHC.Base.String) b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s (Data.Either.Either GHC.Base.String) a)
                   (k :: Control.Monad.Trans.State.Lazy.StateT
                           s (Data.Either.Either GHC.Base.String) b)
                   (s1 :: s) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <s>_N <Data.Either.Either GHC.Base.String>_R <a>_N)
                        s1 of wild {
                   Data.Either.Left l
                   -> Data.Either.Left @ [GHC.Types.Char] @ (b, s) l
                   Data.Either.Right r
                   -> k `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <s>_N <Data.Either.Either GHC.Base.String>_R <b>_N)
                        (case r of wild1 { (,) a2 s' -> s' }) })
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s (Data.Either.Either GHC.Base.String) a>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s (Data.Either.Either GHC.Base.String) b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Either.Either GHC.Base.String>_R <b>_N)) -}
5c700a3dc1e78088c18ae7b669b7effd
  $s$fMonadErroreStateT0_$s$fMonadStateT_$c>>= ::
    Control.Monad.Trans.State.Lazy.StateT
      s (Data.Either.Either GHC.Base.String) a
    -> (a
        -> Control.Monad.Trans.State.Lazy.StateT
             s (Data.Either.Either GHC.Base.String) b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either GHC.Base.String) b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(C1(U))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s (Data.Either.Either GHC.Base.String) a)
                   (k :: a
                         -> Control.Monad.Trans.State.Lazy.StateT
                              s (Data.Either.Either GHC.Base.String) b)
                   (s1 :: s) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <s>_N <Data.Either.Either GHC.Base.String>_R <a>_N)
                        s1 of wild {
                   Data.Either.Left l
                   -> Data.Either.Left @ [GHC.Types.Char] @ (b, s) l
                   Data.Either.Right r
                   -> (k (case r of wild1 { (,) a2 s' -> a2 }))
                        `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <s>_N <Data.Either.Either GHC.Base.String>_R <b>_N)
                        (case r of wild1 { (,) a2 s' -> s' }) })
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s (Data.Either.Either GHC.Base.String) a>_R
                 ->_R <a
                       -> Control.Monad.Trans.State.Lazy.StateT
                            s (Data.Either.Either GHC.Base.String) b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Either.Either GHC.Base.String>_R <b>_N)) -}
80fc9c683a82122169918dbfd2330989
  $s$fMonadErroreStateT0_$s$fMonadStateT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either GHC.Base.String) a
  {- Arity: 2, Strictness: <B,U><B,A>x, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ s @ a (str :: GHC.Base.String) (ds :: s) ->
                 GHC.Err.errorWithoutStackTrace
                   @ 'GHC.Types.LiftedRep
                   @ (Data.Either.Either [GHC.Types.Char] (a, s))
                   str)
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <GHC.Base.String>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Either.Either GHC.Base.String>_R <a>_N)) -}
d92bd4d56a12dd6a5c50b8627cc255cf
  $s$fMonadErroreStateT2 ::
    Control.Monad.Trans.State.Lazy.StateT
      s (Data.Either.Either GHC.Base.String) a
    -> ([GHC.Types.Char]
        -> Control.Monad.Trans.State.Lazy.StateT
             s (Data.Either.Either GHC.Base.String) a)
    -> s
    -> Data.Either.Either GHC.Base.String (a, s)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(C1(U))><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ s
                   @ a
                   (eta4 :: Control.Monad.Trans.State.Lazy.StateT
                              s (Data.Either.Either GHC.Base.String) a)
                   (eta5 :: [GHC.Types.Char]
                            -> Control.Monad.Trans.State.Lazy.StateT
                                 s (Data.Either.Either GHC.Base.String) a)
                   (eta6 :: s) ->
                 case eta4
                        `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <s>_N <Data.Either.Either GHC.Base.String>_R <a>_N)
                        eta6 of wild {
                   Data.Either.Left l
                   -> (eta5 l)
                        `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <s>_N <Data.Either.Either GHC.Base.String>_R <a>_N)
                        eta6
                   Data.Either.Right r
                   -> Data.Either.Right @ [GHC.Types.Char] @ (a, s) r }) -}
812efbafd68fbd09711ac3b689303d3c
  $sinsert_$sgo13 ::
    GHC.Base.String
    -> GHC.Base.String
    -> a1
    -> Data.Map.Internal.Map GHC.Base.String a1
    -> Data.Map.Internal.Map GHC.Base.String a1
  {- Arity: 4, Strictness: <L,U><S,1*U><L,U><S,1*U> -}
dfd640e697cc425e7558aff1d60952bf
  $slookup1 ::
    GHC.Base.String
    -> Data.Map.Internal.Map GHC.Base.String a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
0faaded6c2d40b2165f3a5f609cc28a5
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Eval.$trModule3 Eval.$trModule1) -}
6708f0267d410675a61461a5ff81dd7a
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Eval.$trModule2) -}
98176433f424e963ef37d13893626629
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Eval"#) -}
693638eb15272dc92a8494be9f77a827
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Eval.$trModule4) -}
3af1c024eb4282bbc101a6864567595d
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("LETLanguage-0.1.0.0-AjjNVn9s5sDzZ7DWIwnd3"#) -}
c4a867d96497950c3e949e8178e78244
  type Env = Data.Map.Internal.Map GHC.Base.String Val.Val
f19e4e5dadeea25199b99be090f648e3
  evaluate :: Expr.Expr -> Data.Either.Either GHC.Base.String Val.Val
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (expr :: Expr.Expr) ->
                 case Eval.evaluate1
                        expr
                        (Data.Map.Internal.Tip @ GHC.Base.String @ Val.Val) of wild {
                   Data.Either.Left l
                   -> Data.Either.Left @ [GHC.Types.Char] @ Val.Val l
                   Data.Either.Right r
                   -> Data.Either.Right
                        @ [GHC.Types.Char]
                        @ Val.Val
                        (case r of wild1 { (,) a2 ds1 -> a2 }) }) -}
7bae98a45d881e6c8a2feed6e08231cc
  evaluate1 ::
    Expr.Expr
    -> Data.Map.Internal.Map GHC.Base.String Val.Val
    -> Data.Either.Either
         GHC.Base.String
         (Val.Val, Data.Map.Internal.Map GHC.Base.String Val.Val)
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
7ff3d8dbe30f1b69c364bef86162a4f4
  run ::
    GHC.Base.String -> Data.Either.Either GHC.Base.String Val.Val
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 case (Text.Parsec.Prim.runPT
                         @ GHC.Base.String
                         @ Data.Functor.Identity.Identity
                         @ GHC.Types.Char
                         @ ()
                         @ Expr.Expr
                         (Parser.$s$fStream[]mtok @ GHC.Types.Char)
                         Parser.parseProgram3
                           `cast`
                         (Sym (Text.Parsec.Prim.N:ParsecT[0]
                                   <[GHC.Types.Char]>_R
                                   <()>_R
                                   <Data.Functor.Identity.Identity>_R
                                   <Expr.Expr>_R))
                         GHC.Tuple.()
                         Parser.parseProgram_name
                         s)
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <Data.Either.Either
                              Text.Parsec.Error.ParseError Expr.Expr>_R) of wild {
                   Data.Either.Left perror
                   -> Data.Either.Left
                        @ [GHC.Types.Char]
                        @ Val.Val
                        (GHC.CString.unpackAppendCString#
                           Eval.run4
                           (case perror of wild1 { Text.Parsec.Error.ParseError pos _msgs ->
                            case pos of wild2 { Text.Parsec.Pos.SourcePos _name dt dt1 ->
                            case GHC.Show.$wshowSignedInt
                                   0#
                                   dt
                                   (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                            GHC.Base.++
                              @ GHC.Types.Char
                              (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                              (GHC.CString.unpackAppendCString#
                                 Eval.run3
                                 (case GHC.Show.$wshowSignedInt
                                         0#
                                         dt1
                                         (GHC.Types.[] @ GHC.Types.Char) of ww1 { (#,#) ww2 ww3 ->
                                  GHC.Base.++
                                    @ GHC.Types.Char
                                    (GHC.Types.: @ GHC.Types.Char ww2 ww3)
                                    Eval.run1 })) } } }))
                   Data.Either.Right expr -> Eval.evaluate expr }) -}
37d4224047c33b316e4015bf8e2cf5e2
  run1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Eval.run2) -}
e62fe088f9debb6f408053e6cb218c4e
  run2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (")"#) -}
852571c429375d24042578b11bedfcaf
  run3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (":"#) -}
47e8bb6364d6c7c3219b990dc6b16b65
  run4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ParseError ("#) -}
"SPEC/Eval $fApplicativeStateT @ (Either String) _" [orphan] forall @ s
                                                                    (v1 :: GHC.Base.Monad
                                                                             (Data.Either.Either
                                                                                GHC.Base.String))
                                                                    (v :: GHC.Base.Functor
                                                                            (Data.Either.Either
                                                                               GHC.Base.String))
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT @ (Data.Either.Either
                                                          GHC.Base.String)
                                                     @ s
                                                     v
                                                     v1
  = Eval.$s$fApplicativeStateT @ s
"SPEC/Eval $fApplicativeStateT_$c<*> @ (Either String) _" [orphan] forall @ s
                                                                          ($dMonad :: GHC.Base.Monad
                                                                                        (Data.Either.Either
                                                                                           GHC.Base.String))
                                                                          ($dFunctor :: GHC.Base.Functor
                                                                                          (Data.Either.Either
                                                                                             GHC.Base.String))
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c<*> @ (Data.Either.Either
                                                                GHC.Base.String)
                                                           @ s
                                                           $dFunctor
                                                           $dMonad
  = Eval.$s$fApplicativeStateT_$s$fApplicativeStateT_$c<*> @ s
"SPEC/Eval $fApplicativeStateT_$cpure @ (Either String) _" [orphan] forall @ s
                                                                           ($dMonad :: GHC.Base.Monad
                                                                                         (Data.Either.Either
                                                                                            GHC.Base.String))
                                                                           ($dFunctor :: GHC.Base.Functor
                                                                                           (Data.Either.Either
                                                                                              GHC.Base.String))
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$cpure @ (Data.Either.Either
                                                                 GHC.Base.String)
                                                            @ s
                                                            $dFunctor
                                                            $dMonad
  = Eval.$s$fApplicativeStateT_$s$fApplicativeStateT_$cpure @ s
"SPEC/Eval $fFunctorStateT @ (Either String) _" [orphan] forall @ s
                                                                (v :: GHC.Base.Functor
                                                                        (Data.Either.Either
                                                                           GHC.Base.String))
  Control.Monad.Trans.State.Lazy.$fFunctorStateT @ (Data.Either.Either
                                                      GHC.Base.String)
                                                 @ s
                                                 v
  = Eval.$s$fApplicativeStateT_$s$fFunctorStateT @ s
"SPEC/Eval $fMonadErroreStateT0 @ [Char] @ (Either String) _" [orphan] forall @ s
                                                                              (v :: Control.Monad.Error.Class.MonadError
                                                                                      [GHC.Types.Char]
                                                                                      (Data.Either.Either
                                                                                         GHC.Base.String))
  Control.Monad.Error.Class.$fMonadErroreStateT0 @ [GHC.Types.Char]
                                                 @ (Data.Either.Either GHC.Base.String)
                                                 @ s
                                                 v
  = Eval.$s$fMonadErroreStateT0 @ s
"SPEC/Eval $fMonadErroreStateT2 @ [Char] @ (Either String) _" [orphan] forall @ s
                                                                              ($dMonadError :: Control.Monad.Error.Class.MonadError
                                                                                                 [GHC.Types.Char]
                                                                                                 (Data.Either.Either
                                                                                                    GHC.Base.String))
  Control.Monad.Error.Class.$fMonadErroreStateT2 @ [GHC.Types.Char]
                                                 @ (Data.Either.Either GHC.Base.String)
                                                 @ s
                                                 $dMonadError
  = Eval.$s$fMonadErroreStateT2 @ s
"SPEC/Eval $fMonadStateT @ (Either String) _" [orphan] forall @ s
                                                              (v :: GHC.Base.Monad
                                                                      (Data.Either.Either
                                                                         GHC.Base.String))
  Control.Monad.Trans.State.Lazy.$fMonadStateT @ (Data.Either.Either
                                                    GHC.Base.String)
                                               @ s
                                               v
  = Eval.$s$fMonadErroreStateT0_$s$fMonadStateT @ s
"SPEC/Eval $fMonadStateT_$c>> @ (Either String) _" [orphan] forall @ s
                                                                   ($dMonad :: GHC.Base.Monad
                                                                                 (Data.Either.Either
                                                                                    GHC.Base.String))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>> @ (Data.Either.Either
                                                         GHC.Base.String)
                                                    @ s
                                                    $dMonad
  = Eval.$s$fMonadErroreStateT0_$s$fMonadStateT_$c>> @ s
"SPEC/Eval $fMonadStateT_$c>>= @ (Either String) _" [orphan] forall @ s
                                                                    ($dMonad :: GHC.Base.Monad
                                                                                  (Data.Either.Either
                                                                                     GHC.Base.String))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>= @ (Data.Either.Either
                                                          GHC.Base.String)
                                                     @ s
                                                     $dMonad
  = Eval.$s$fMonadErroreStateT0_$s$fMonadStateT_$c>>= @ s
"SPEC/Eval $fMonadStateT_$cfail @ (Either String) _" [orphan] forall @ s
                                                                     ($dMonad :: GHC.Base.Monad
                                                                                   (Data.Either.Either
                                                                                      GHC.Base.String))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$cfail @ (Data.Either.Either
                                                           GHC.Base.String)
                                                      @ s
                                                      $dMonad
  = Eval.$s$fMonadErroreStateT0_$s$fMonadStateT_$cfail @ s
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

